# o4raft
学分布式算法,只知其意,尝试尝试找点感触;
最近在学Dubbo和Netty,锻炼一下灵活应用;

## Raft 参考

## 设想

1. raft集群总是有一个发现中心,可以实时地推送当前集群的结点端口
2. 暂时不考虑集群数量的动态变更【TODO】,在所有结点启动时已经指明当前集群的数量
3. 当已有结点数 n > N/2 +1 时,某个结点就可以开启运作;
4. 每个结点都是RPC服务提供者,提供定义的两个基础RPC服务
5. 每个结点都有三种状态,follower\condidator\leader
6. 三种状态之间的转换由RPC服务被调用后触发
7. 每个结点除了dubbo框架跑的线程,尽量线程单一化
8. 超时可能有两种,触发两类状态转换,心跳等待超时以及选举分片超时


## 从0到1

### 只实现选举
#### 结点的注册 --》》暂定
每个结点都会定时地向注册中心redis推送自己还活着的信息，如果自己挂了，要保证redis在一定时间内知道你挂了；
1. 方案a1 与redis建立长连接，每次推送活着的信息的时候，给自己一个死亡时间 1s?;redis数据结构 key : val 
2. 方案a2 直接用dubbo的原生方案，但是此时我需要自定义调用策略（尝试）

#### rpc服务 --》》暂定
每个结点都有两个rpc服务,但是这两个rpc服务我们需要使其产生关联 
1. 方案1 Map<port,rpcService1> Map<port,rpcService2>
2. 方案2 一个RpcPoint作为每个结点的门面，背后的逻辑借助Dubbo的分组调用和分组聚合实现 (尝试)

#### 结点间的建连 (先不去检测是否结点大于等于 n/2 +1 ，手动开启) --》》暂定
dubbo服务使用的是长连接,即每个结点在正常运行时都会与其它所有结点建立长连接，这是由dubbo维护的。
1. 方案a1 每个端点暴露的服务不去注册,而是自己推到redis中，然后自己去维护一个注册服务与断连的更新服务
2. 方法a2 但是我当前还不是很理解如何让dubbo不去做负载均衡,而是把所有对应结点直接给我..不要负载,而是要所有结点
                                                        但是这里也可以考虑直接的聚合 --》暂且可行

#### 第一阶段尝试 
1. 开启5个服务,并启动一个消费者不断与4个服务进行接口的回声测试(使用分组调用 ，并且回复使用分组聚合，自定一Merger) DONE
2. 开启5个服务,并使所有服务停在原地不动等20秒加一个随机的时间,当某个结点跑起来后,所有结点都跟随它,然后进入1的回声测试
3. 1）所有结点启动时都绑定一个当前结点数n,所有新加入的结点都会20秒才会主动去尝试选举，但是在sleep过程中如果有其它结点发起投票并成功然后发来了心跳，则自动变为follower
   2）leader断开,当剩余结点大于法定结点是,能正确地选举
   3) [TODO]当结点小于法定结点,领导者没有判别
   4) [TODO]当领导者调用过程中,某个结点断开,领导者没有处理调用的异常
   
[TODO]
4. 加入基于zookeeper或者reddis的分布式锁,实现良好的启动过程
5. 如果集群中的结点死的还剩一半以下,则会进入无限的选举过程中 --> 但是任期不会因为新加入的结点而变小 (对状态的修改应该是保证线程安全的,但是当下无法确定竞态条件)
### 实现消息一致
//TODO
### 实现动态集群可配置
//TODO
